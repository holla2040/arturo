# Arturo

Industrial test automation system built on ESP32 stations and a centralized Go controller, connected via Redis.

## Terminology

| Term | What it is | Who needs to know |
|------|-----------|-------------------|
| **Arturo** | The whole system | Everyone |
| **Station** | ESP32 + its connected instruments (e.g., "DMM station", "relay station") | Operator + engineer |
| **Terminal** | Screen, keyboard, barcode scanner — the operator interface | Operator |
| **Controller** | Go processes that orchestrate tests, manage stations, store data | Engineer |
| **File server** | Separate network machine where reports are stored | Operator + engineer |

The terminal and controller run on the same Ubuntu machine. The operator sees the terminal and the stations. The controller works behind the scenes.

## Naming Conventions

| Word | Meaning |
|------|---------|
| **timestamp** | UTC epoch seconds (integer). Always UTC, never local. |
| **time** | Local time (US/Denver). |
| **date** | Local date/time (US/Denver). |

Wherever a field or variable is called `timestamp`, it is UTC epoch seconds. Wherever it is called `time` or `date`, it is in local time (US/Denver).

## Architecture

```
Stations (up to 6)          <--Redis Streams/PubSub-->     Controller (Go)
  C++ / Arduino                                              │
  - SCPI instruments                                    controller
  - Serial devices                                       - Device registry
  - Relay control                                        - REST API + WebSocket
  - Modbus devices                                       - SQLite data storage
  - Safety interlocks                                    - Health monitoring
                                                         engine
         Terminal                                        - Script engine (.art DSL)
  - Screen + keyboard                                    - Test orchestration
  - Barcode scanner                                      - LLM-assisted script generation
  - Web terminal
```

## Project Structure

```
arturo/
├── docs/
│   ├── architecture/
│   │   └── ARCHITECTURE.md             # Architecture decisions and protocol spec
│   └── reference/                      # Reference material from arturo-go-archive
├── schemas/                            # Protocol v1.0.0 message schemas
│   └── v1.0.0/
│       ├── envelope/                   # Shared message envelope
│       ├── error/                      # Shared error object
│       ├── device-command-request/     # Controller -> Station command
│       ├── device-command-response/    # Station -> Controller result
│       ├── service-heartbeat/          # Station health report (30s interval)
│       ├── system-emergency-stop/      # E-stop broadcast
│       └── system-ota-request/         # OTA firmware update
├── services/                            # Go services that run on the controller machine
│   ├── README.md                       # Service architecture and build instructions
│   ├── cmd/
│   │   ├── controller/                 # API, device registry, health, data storage
│   │   ├── console/                   # Mock stations + web console (development)
│   │   └── terminal/                  # Operator web UI (reverse proxy to controller)
├── tools/                              # Tools (invoke and exit)
│   ├── engine/                        # Script parser + executor
│   └── monitor/                       # Redis traffic monitor (debugging)
├── firmware/                           # Station firmware (ESP32 Arduino)
│   ├── README.md                       # Firmware architecture decisions
│   ├── src/
│   │   ├── network/                    # WiFi, Redis client
│   │   ├── messaging/                  # Protocol v1.0.0 envelope, command handler, heartbeat
│   │   ├── protocols/                  # SCPI, Modbus, CTI, ASCII packetizers
│   │   ├── devices/                    # TCP, serial, relay, modbus device drivers
│   │   └── safety/                     # Watchdog, E-stop, interlocks
│   └── test/
├── profiles/                           # Device profile YAMLs
└── scripts/                           # Test scripts (.art) and shared libraries (.artlib)
```

## Scripting

Test definitions are `.art` script files — the single source of truth for what a test does. Scripts can be written by hand or generated by an LLM. The Arturo DSL is a plain-text, deterministic grammar designed for both human and machine authoring.

**Key design decisions:**
- **Station-scoped execution** — a script runs on one station. The operator picks the station in the terminal, loads a script, and runs it. Scripts never address stations by name; they issue commands against whatever station they're bound to. The same script works on any station with the same instrument capabilities.
- **Profile-based abstraction** — scripts use logical command names (e.g. `"first_stage_temp"`), not raw protocol commands. Device profiles (YAML in `profiles/`) map logical names to the actual SCPI, Modbus, CTI, or ASCII protocol calls. Script authors don't need to know the protocol.

**Engine status:** The engine (`tools/engine`) has a complete lexer/parser with structured JSON error output, a working AST executor with scoped variables, and Redis-backed device communication with UUID-correlated request/response. See [SCRIPTING_DISCUSSION.md](SCRIPTING_DISCUSSION.md) for current state details and open design questions.

**References:**
- [docs/SCRIPTING_HAL.md](docs/SCRIPTING_HAL.md) — HAL reference (abstract command vocabulary per device type)
- [docs/reference/SCRIPTING_LANGUAGE_ORIGINAL.md](docs/reference/SCRIPTING_LANGUAGE_ORIGINAL.md) — language reference
- [ARCHITECTURE.md Section 2.8](docs/architecture/ARCHITECTURE.md) — design constraints
- [SCRIPTING_DISCUSSION.md](SCRIPTING_DISCUSSION.md) — design decisions, engine status, and talking points

## ESP32-S3 Pin Assignments

| Function | GPIO | UART | Notes |
|----------|------|------|-------|
| CTI OnBoard RX (PUMP-01) | 17 | UART1 RXD | RS-232 via MAX3232, 2400 7E1 |
| CTI OnBoard TX (PUMP-01) | 18 | UART1 TXD | RS-232 via MAX3232, 2400 7E1 |
| USB Serial (debug) | — | UART0 | 115200 8N1, CDC on boot |

## Key Decisions

- **Go** on the controller, **C++** on stations, **Redis** in the middle
- **Arduino framework** with Arduino CLI (not IDE), FreeRTOS tasks for concurrency
- **Redis Streams** for reliable command/response delivery (per-station channels)
- **Redis Pub/Sub** for heartbeats and emergency stop (fire-and-forget)
- **Protocol v1.0.0 envelope** on every message (JSON, same format on stations and controller)
- **5 message types**: `device.command.request`, `device.command.response`, `service.heartbeat`, `system.emergency_stop`, `system.ota.request`
- **Direct station-to-Redis** connection (no MQTT broker, no middleware)
- **2 controller processes** (not 39)
- **OTA firmware updates** via ESP-IDF dual-partition with automatic rollback
- **Schemas as single source of truth** — code implements what the schemas define
- **Scripts as orchestration** — `.art` files are test definitions, authorable by humans and LLMs

## Message Flow

```
Controller                      Redis                        Station
  │                               │                             │
  │── XADD commands:station-01 ──>│                             │
  │                               │──── XREAD BLOCK ───────────>│
  │                               │                             │── execute on device
  │                               │<──── XADD responses:ctrl ───│
  │<── XREAD ────────────────────-│                             │
  │                               │                             │
  │                               │<── PUBLISH events:heartbeat │  (every 30s)
  │<── SUBSCRIBE ────────────────-│                             │
```

## Getting Started

1. Read [schemas/v1.0.0/README.md](schemas/v1.0.0/README.md) — the protocol definitions
2. Read [services/README.md](services/README.md) — Go services architecture
3. Read [firmware/README.md](firmware/README.md) — station firmware architecture
4. Read [docs/architecture/ARCHITECTURE.md](docs/architecture/ARCHITECTURE.md) — architecture decisions

## Related

- [arturo-go-archive](https://github.com/holla2040/arturo-go-archive) — Original Go microservices implementation (reference only)
