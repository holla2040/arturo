# Arturo

Industrial test automation system built on ESP32 stations and a centralized Go controller, connected via Redis.

## Terminology

| Term | What it is | Who needs to know |
|------|-----------|-------------------|
| **Arturo** | The whole system | Everyone |
| **Station** | ESP32 + its connected instruments (e.g., "DMM station", "relay station") | Operator + engineer |
| **Terminal** | Screen, keyboard, barcode scanner — the operator interface | Operator |
| **Controller** | Go processes that orchestrate tests, manage stations, store data | Engineer |
| **File server** | Separate network machine where reports are stored | Operator + engineer |

The terminal and controller run on the same Ubuntu machine. The operator sees the terminal and the stations. The controller works behind the scenes.

## Naming Conventions

| Word | Meaning |
|------|---------|
| **timestamp** | UTC epoch seconds (integer). Always UTC, never local. |
| **time** | Local time (US/Denver). |
| **date** | Local date/time (US/Denver). |

Wherever a field or variable is called `timestamp`, it is UTC epoch seconds. Wherever it is called `time` or `date`, it is in local time (US/Denver).

## Architecture

```
Stations (up to 6)          <--Redis Streams/PubSub-->     Controller (Go)
  C++ / Arduino                                              │
  - SCPI instruments                                    arturo-server
  - Serial devices                                       - Device registry
  - Relay control                                        - REST API + WebSocket
  - Modbus devices                                       - SQLite data storage
  - Safety interlocks                                    - Health monitoring
                                                         arturo-engine
         Terminal                                        - Script engine (.art DSL)
  - Screen + keyboard                                    - Test orchestration
  - Barcode scanner                                      - LLM-assisted script generation
  - Web dashboard
```

## Project Structure

```
arturo/
├── docs/
│   ├── architecture/
│   │   └── ARCHITECTURE.md             # Architecture decisions and protocol spec
│   └── reference/                      # Reference material from arturo-go-archive
├── schemas/                            # Protocol v1.0.0 message schemas
│   └── v1.0.0/
│       ├── envelope/                   # Shared message envelope
│       ├── error/                      # Shared error object
│       ├── device-command-request/     # Controller -> Station command
│       ├── device-command-response/    # Station -> Controller result
│       ├── service-heartbeat/          # Station health report (30s interval)
│       ├── system-emergency-stop/      # E-stop broadcast
│       └── system-ota-request/         # OTA firmware update
├── server/                             # Controller (Go processes)
│   └── cmd/
│       ├── arturo-server/              # Main process (API, device registry, data, health)
│       ├── arturo-engine/              # Script parser + executor
│       └── arturo-monitor/             # Redis traffic monitor (debugging)
├── firmware/                           # Station firmware (ESP32 Arduino)
│   ├── README.md                       # Firmware architecture decisions
│   ├── src/
│   │   ├── network/                    # WiFi, Redis client
│   │   ├── messaging/                  # Protocol v1.0.0 envelope, command handler, heartbeat
│   │   ├── protocols/                  # SCPI, Modbus, CTI, ASCII packetizers
│   │   ├── devices/                    # TCP, serial, relay, modbus device drivers
│   │   └── safety/                     # Watchdog, E-stop, interlocks
│   └── test/
├── profiles/                           # Device profile YAMLs
└── scripts/                           # Test scripts (.art) and shared libraries (.artlib)
```

## Scripting

Test definitions are `.art` script files — the single source of truth for what a test does. Scripts can be written by hand or generated by an LLM. The Arturo DSL is a plain-text, deterministic grammar designed for both human and machine authoring. See [docs/reference/SCRIPTING_LANGUAGE_ORIGINAL.md](docs/reference/SCRIPTING_LANGUAGE_ORIGINAL.md) for the language reference and [ARCHITECTURE.md Section 2.8](docs/architecture/ARCHITECTURE.md) for design constraints.

## ESP32-S3 Pin Assignments

| Function | GPIO | UART | Notes |
|----------|------|------|-------|
| CTI OnBoard RX (PUMP-01) | 17 | UART1 RXD | RS-232 via MAX3232, 2400 7E1 |
| CTI OnBoard TX (PUMP-01) | 18 | UART1 TXD | RS-232 via MAX3232, 2400 7E1 |
| USB Serial (debug) | — | UART0 | 115200 8N1, CDC on boot |

## Key Decisions

- **Go** on the controller, **C++** on stations, **Redis** in the middle
- **Arduino framework** with Arduino CLI (not IDE), FreeRTOS tasks for concurrency
- **Redis Streams** for reliable command/response delivery (per-station channels)
- **Redis Pub/Sub** for heartbeats and emergency stop (fire-and-forget)
- **Protocol v1.0.0 envelope** on every message (JSON, same format on stations and controller)
- **5 message types**: `device.command.request`, `device.command.response`, `service.heartbeat`, `system.emergency_stop`, `system.ota.request`
- **Direct station-to-Redis** connection (no MQTT broker, no middleware)
- **2 controller processes** (not 39)
- **OTA firmware updates** via ESP-IDF dual-partition with automatic rollback
- **Schemas as single source of truth** — code implements what the schemas define
- **Scripts as orchestration** — `.art` files are test definitions, authorable by humans and LLMs

## Message Flow

```
Controller                      Redis                        Station
  │                               │                             │
  │── XADD commands:station-01 ──>│                             │
  │                               │──── XREAD BLOCK ───────────>│
  │                               │                             │── execute on device
  │                               │<──── XADD responses:ctrl ───│
  │<── XREAD ────────────────────-│                             │
  │                               │                             │
  │                               │<── PUBLISH events:heartbeat │  (every 30s)
  │<── SUBSCRIBE ────────────────-│                             │
```

## Getting Started

1. Read [schemas/v1.0.0/README.md](schemas/v1.0.0/README.md) — the protocol definitions
2. Read [firmware/README.md](firmware/README.md) — station firmware architecture
3. Read [docs/architecture/ARCHITECTURE.md](docs/architecture/ARCHITECTURE.md) — architecture decisions

## Related

- [arturo-go-archive](https://github.com/holla2040/arturo-go-archive) — Original Go microservices implementation (reference only)
